#!/usr/bin/env python

'''
========================
policy_firewall.py
========================
Created on Oct.20, 2017
@author: Xu Ronghua
@Email:  rxu22@binghamton.edu
@TaskDescription: This module provide network firewall policy function, such as ipset, iptables.
@Reference: 
'''

import iptc
import sys
import subprocess
import os

'''
ipset class for wrapping ipset command
'''
class IPSets(object):
	'''
	=========================================Manage ip-set===================================
	'''
	#List the header data and the entries for the specified set, or for all sets if none is given
	@staticmethod
	def list(s_name=''):
		if(s_name==''):
			p = subprocess.Popen(['ipset', 'list'], stdout=subprocess.PIPE)
		else:
			p = subprocess.Popen(['ipset', 'list', s_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
	
	#Create a set identified with setname and specified type
	@staticmethod
	def create(s_name, s_type):
		p = subprocess.Popen(['ipset', 'create', s_name, s_type], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
		
	#Rename a set. Set identified by SETNAME-TO must not exist
	@staticmethod
	def rename(old_name, new_name):
		p = subprocess.Popen(['ipset', 'rename', old_name, new_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
	
	#Destroy the specified set or all the sets if none is given
	@staticmethod
	def destroy(s_name=''):
		if(s_name==''):
			p = subprocess.Popen(['ipset', 'destroy'], stdout=subprocess.PIPE)
		else:
			p = subprocess.Popen(['ipset', 'destroy', s_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
		
	#Flush all entries from the specified set or flush all sets if none is given.
	@staticmethod
	def flush(s_name=''):
		if(s_name==''):
			p = subprocess.Popen(['ipset', 'flush'], stdout=subprocess.PIPE)
		else:
			p = subprocess.Popen(['ipset', 'flush', s_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		#print output
	
	#Save the given set, or all sets if none is given to stdout in a format that restore can read
	@staticmethod
	def save(s_name,f_name):
		if(s_name==''):
			p = subprocess.Popen(['ipset', 'save', '-f', f_name], stdout=subprocess.PIPE)
		else:
			p = subprocess.Popen(['ipset', 'save', s_name, '-f', f_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output

	#Restore a saved session generated by save
	@staticmethod
	def restore(f_name):
		p = subprocess.Popen(['ipset', 'restore', '-f', f_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
	
	'''
	===================================Manage ip-entry===================================
	'''
	#Add a given entry to the set
	@staticmethod
	def add(s_name,e_name):
		p = subprocess.Popen(['ipset', 'add', s_name, e_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
	
	#Delete an entry from a set
	@staticmethod
	def delete(s_name,e_name):
		p = subprocess.Popen(['ipset', 'del', s_name, e_name], stdout=subprocess.PIPE)
		output, err = p.communicate()
		print output
	
'''
policy class for manage iptables rules
'''
class IPTables(object):
    
	#display iptables information
	@staticmethod
	def list_iptables(tb_name='FILTER'):
		if(tb_name=='NAT'):
			table = iptc.Table(iptc.Table.NAT)
		elif(tb_name=='FILTER'):
			table = iptc.Table(iptc.Table.FILTER)
		elif(tb_name=='MANGLE'):
			table = iptc.Table(iptc.Table.MANGLE)
		elif(tb_name=='RAW'):
			table = iptc.Table(iptc.Table.RAW)
		else:
			print("Not supported table.")
			return 
		print "-------Table:" + table.name + "--------"
		for chain in table.chains:
			print "======================="
			print "Chain ", chain.name
			for rule in chain.rules:
				print "Rule", "proto:", rule.protocol, "src:", rule.src, "dst:", \
					rule.dst, "in:", rule.in_interface, "out:", rule.out_interface,
				print "Matches:",
				for match in rule.matches:
					if(match.name=='state'):
						print match.name, '-', match.state
					else:
						print match.name
				print "Target:",
				print rule.target.name
				table = iptc.Table(iptc.Table.FILTER)
		print "======================="
		
	#Save iptables to file
	@staticmethod
	def save(tb_name, f_name):
		if(tb_name==''):
			cmdline="iptables-save > " + f_name			
		else:
			cmdline="iptables-save -t " + tb_name + " > " + f_name
		os.system(cmdline)
		
	#Restore from iptables-save to current iptables
	@staticmethod
	def restore(f_name):	
		cmdline="iptables-restore < " + f_name
		os.system(cmdline)
		
	#Flush the selected chain
	@staticmethod
	def flush(tb_name):
		if(tb_name==''):
			cmdline="iptables -F"		
		else:
			cmdline="iptables -t " + tb_name + " -F"
		os.system(cmdline)

		
if __name__ == '__main__':
	#display_iptc_table() 
	pass
