#include "../include/ObjectDetect.h"
#include "../include/Utilities.h"
#include <cstring>

ObjDetect::ObjDetect(){
	strcpy(mStrOpencvData, "D:/ProgramFiles/opencv_3.2_dev/sources/opencv/data/");
	mBgSubMOG = bgsegm::createBackgroundSubtractorMOG();  //MOG approach
	mBgSubMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
}

int ObjDetect::setface_cascade(char* cascadepath) {
	char strPath[256];
	strcpy(strPath, mStrOpencvData);
	strcat(strPath, cascadepath);
	return face_cascade.load(strPath);
}

int ObjDetect::seteye_cascade(char* cascadepath) {
	char strPath[256];
	strcpy(strPath, mStrOpencvData);
	strcat(strPath, cascadepath);
	return eyes_cascade.load(strPath);
}

int ObjDetect::detectFace(Mat frame, vector<cv::Rect> &faces) {
	//load cascade
	if (!setface_cascade("haarcascades/haarcascade_frontalface_alt.xml")) {
		printf("Error loading face cascade\n");
		return -1;
	}

	//std::vector<Rect> faces;
	Mat frame_gray;
	cvtColor(frame, frame_gray, COLOR_BGR2GRAY);
	equalizeHist(frame_gray, frame_gray);

	//-- Detect faces
	face_cascade.detectMultiScale(frame_gray, faces, 1.3, 5, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));

	//draw face
	/*for (size_t i = 0; i < faces.size(); i++) {
		//Point center(faces[i].x + faces[i].width / 2, faces[i].y + faces[i].height / 2);
		//ellipse(frame, center, Size(faces[i].width / 2, faces[i].height / 2), 0, 0, 360, Scalar(0, 255, 0), 2, 8, 0);
		rectangle(frame, faces[i], Scalar(0, 255, 0), 2, 8, 0);
	}*/
	return 0;
}

int  ObjDetect::detectEye(Mat frame, std::vector<cv::Rect> &eyes) {
	//load cascade
	if (!setface_cascade("haarcascades/haarcascade_frontalface_alt.xml")) {
		printf("Error loading face cascade\n");
		return -1;
	}
	if (!seteye_cascade("/haarcascades/haarcascade_eye.xml")) {
		printf("Error loading eye cscade\n");
		return -1;
	}

	std::vector<cv::Rect> faces;
	Mat frame_gray;
	cvtColor(frame, frame_gray, COLOR_BGR2GRAY);
	equalizeHist(frame_gray, frame_gray);

	//-- Detect faces
	face_cascade.detectMultiScale(frame_gray, faces, 1.3, 5, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));

	//-- In each face, detect eyes
	for (size_t i = 0; i < faces.size(); i++) {
		//mark face
		Point center(faces[i].x + faces[i].width / 2, faces[i].y + faces[i].height / 2);
		ellipse(frame, center, Size(faces[i].width / 2, faces[i].height / 2), 0, 0, 360, Scalar(0, 255, 0), 2, 8, 0);

		Mat faceROI = frame_gray(faces[i]);
		vector<cv::Rect> eyes;

		//-- In each face, detect eyes
		eyes_cascade.detectMultiScale(faceROI, eyes, 1.1, 2, 0 | CASCADE_SCALE_IMAGE, Size(30, 30));

		//draw eyes
		for (size_t j = 0; j < eyes.size(); j++)
		{
			Point eye_center(faces[i].x + eyes[j].x + eyes[j].width / 2, faces[i].y + eyes[j].y + eyes[j].height / 2);
			int radius = cvRound((eyes[j].width + eyes[j].height)*0.25);
			circle(frame, eye_center, radius, Scalar(255, 0, 0), 2, 8, 0);
		}
	}
	return 0;
}

int ObjDetect::detectMotionMOG(Mat frame, vector<cv::Rect> &found_filtered, int mode, int minArea) {
	//fg mask generated by MOG method
	Mat fgmask;	

	//Blur Filtering
	Mat blur;
	medianBlur(frame, blur, 5);

	//update the background model
	if (mode == MotionMethod::MOG) {
		mBgSubMOG->apply(blur, fgmask);
	}
	else if (mode == MotionMethod::MOG2) {
		//update the background model
		mBgSubMOG2->apply(blur, fgmask);
	}
	else {
		return -1;
	}

	//threshold to remove shadow
	threshold(fgmask, fgmask, 127, 255, THRESH_BINARY);

	//noise removal
	Mat kernel = getStructuringElement(MORPH_RECT, Size(2 , 2), Point(0, 0));
	erode(fgmask, fgmask, kernel);
	morphologyEx(fgmask, fgmask, MORPH_OPEN, kernel);
	morphologyEx(fgmask, fgmask, MORPH_CLOSE, kernel);
	dilate(fgmask, fgmask, kernel);

	//calculate contours
	vector<vector<Point> > contours;
	vector<Vec4i> hierarchy;

	findContours(fgmask, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE, Point(0, 0));

	//filter contours
	//vector<cv::Rect> found_filtered;
	found_filtered =Utilities::cont_filter(contours, minArea);
	
	//cout << found_filtered.size() << "\n";
	//cout << found_filtered[0] << "\n";

	//Utilities::draw_detections(frame, found_filtered, Scalar(0, 255, 255));

	/*Mat drawing = Mat::zeros(fgmask.size(), CV_8UC3);
	RNG rng(255);
	Rect  boundRect;
	for (size_t i = 0; i< contours.size(); i++)
	{
		Scalar color = Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		//drawContours(drawing, contours, (int)i, color, 2, 8, hierarchy, 0, Point());
		boundRect = boundingRect(contours[i]);
		rectangle(frame, boundRect.tl(), boundRect.br(), Scalar(0, 255, 0), 2, 8, 0);
	}*/

	//imshow("FG Mask MOG", fgmask);

	return 0;
}